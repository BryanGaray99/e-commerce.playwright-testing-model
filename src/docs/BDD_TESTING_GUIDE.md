# üß™ Gu√≠a de Testing BDD con Playwright y Cucumber

## üìã √çndice
1. [Estructura del Proyecto](#estructura-del-proyecto)
2. [Buenas Pr√°cticas](#buenas-pr√°cticas)
3. [Patrones de C√≥digo](#patrones-de-c√≥digo)
4. [Depuraci√≥n de Errores](#depuraci√≥n-de-errores)
5. [Aprendizajes Clave](#aprendizajes-clave)
6. [Troubleshooting](#troubleshooting)
7. [Lecciones Aprendidas](#lecciones-aprendidas)

---

## üèóÔ∏è Estructura del Proyecto

### Organizaci√≥n de Directorios
```
src/
‚îú‚îÄ‚îÄ api/                    # Clientes API
‚îú‚îÄ‚îÄ features/              # Archivos .feature (BDD)
‚îú‚îÄ‚îÄ steps/                 # Definiciones de steps
‚îú‚îÄ‚îÄ fixtures/              # Datos de prueba
‚îú‚îÄ‚îÄ schemas/               # Validaciones JSON Schema
‚îú‚îÄ‚îÄ types/                 # Tipos TypeScript
‚îî‚îÄ‚îÄ docs/                  # Documentaci√≥n
```

### Convenciones de Nomenclatura
- **Features**: `[resource].feature` (ej: `products.feature`)
- **Steps**: `[resource].steps.ts` (ej: `product.steps.ts`)
- **Fixtures**: `[resource].fixture.ts` (ej: `product.fixture.ts`)
- **Schemas**: `[resource].schema.ts` (ej: `product.schema.ts`)

---

## ‚úÖ Buenas Pr√°cticas

### 1. **Estructura de Steps**
```typescript
// ‚úÖ PATR√ìN CORRECTO
Given('a product exists in the system', async function () {
  this.existingProduct = ProductFixture.createProductDto();
  const response = await productsClient.createProduct(this.existingProduct);
  expect(response.status).toBe(201);
  
  const productData = (response.data as any)?.data?.data || response.data;
  this.productId = productData.id;
  storeCreatedEntity('product', this.productId, response.data);
});

When('I update the product', async function () {
  this.updateData = ProductFixture.updateProductDto();
  
  try {
    const response = await productsClient.updateProduct(this.productId, this.updateData);
    handleApiResponse(response);
  } catch (error: any) {
    console.log(`‚ùå Error updating product ${this.productId}:`, error.status || 'Unknown error');
    handleApiResponse(null, error);
  }
});

Then('the product should be updated successfully', function () {
  const response = getLastResponse();
  const error = getLastError();

  if (error) {
    console.log(`‚ùå Update failed:`, error);
  }

  expect(response).toBeTruthy();
  expect(response.status).toBe(200);
  expect(response.data).toBeTruthy();

  const productData = (response.data as any)?.data?.data || response.data;
  Object.keys(this.updateData).forEach(key => {
    let expected = this.updateData[key];
    let actual = productData[key];
    if (["price", "stock"].includes(key)) {
      expected = Number(expected);
      actual = Number(actual);
    }
    expect(actual).toBe(expected);
  });

  expect(isValidProduct(productData)).toBe(true);
});
```

### 2. **Manejo de Respuestas API**
```typescript
// ‚úÖ PATR√ìN CORRECTO - Estructura anidada
const productData = (response.data as any)?.data?.data || response.data;

// ‚ùå PATR√ìN INCORRECTO - Acceso directo
const productData = response.data;
```

### 3. **Logs Estrat√©gicos**
```typescript
// ‚úÖ SOLO LOGS ESENCIALES
// Logs de error con contexto
console.log(`‚ùå Error updating product ${this.productId}:`, error.status || 'Unknown error');

// Logs de fallo en validaciones
if (error) {
  console.log(`‚ùå Update failed:`, error);
}

// ‚ùå LOGS EXCESIVOS (evitar)
console.log('üîç Response data:', JSON.stringify(response.data, null, 2));
console.log('üîç Creating product:', JSON.stringify(productData, null, 2));
```

### 4. **Solo se pueden actualizar campos definidos en el DTO**
- Cuando se realiza un PATCH/PUT, **solo los campos definidos en el DTO correspondiente pueden ser actualizados**.
- Si intentas enviar un campo extra (no definido en el DTO), el ValidationPipe de NestJS lo rechazar√° (por ejemplo, con `forbidNonWhitelisted: true`).
- Para que un campo sea actualizable, debe estar expl√≠citamente en el DTO de update (ej: `UpdateUserDto`, `UpdateProductDto`, etc.).
- Las interfaces (`User`, `Product`, etc.) solo definen la forma del objeto en memoria, pero **no controlan la validaci√≥n de entrada**.
- Ejemplo: Si quieres permitir actualizar `isActive` en usuario, agr√©galo al `UpdateUserDto`.

---

## üîß Patrones de C√≥digo

### 1. **Manejo de Errores Consistente**
```typescript
// Patr√≥n est√°ndar para When steps
When('I [action] the [resource]', async function () {
  try {
    const response = await [client].[method]([params]);
    handleApiResponse(response);
  } catch (error: any) {
    console.log(`‚ùå Error [action] [resource] ${this.[resource]Id}:`, error.status || 'Unknown error');
    handleApiResponse(null, error);
  }
});
```

### 2. **Validaci√≥n de Respuestas**
```typescript
// Patr√≥n est√°ndar para Then steps
Then('the [resource] should be [action] successfully', function () {
  const response = getLastResponse();
  const error = getLastError();

  if (error) {
    console.log(`‚ùå [Action] failed:`, error);
  }

  expect(response).toBeTruthy();
  expect(response.status).toBe([expectedStatus]);
  expect(response.data).toBeTruthy();

  const [resource]Data = (response.data as any)?.data?.data || response.data;
  // Validaciones espec√≠ficas...
  expect(isValid[Resource]([resource]Data)).toBe(true);
});
```

### 3. **Comparaci√≥n de Tipos**
```typescript
// Para campos num√©ricos (price, stock, etc.)
Object.keys(this.updateData).forEach(key => {
  let expected = this.updateData[key];
  let actual = productData[key];
  if (["price", "stock"].includes(key)) {
    expected = Number(expected);
    actual = Number(actual);
  }
  expect(actual).toBe(expected);
});
```

---

## üêõ Depuraci√≥n de Errores

### 1. **Errores Comunes y Soluciones**

#### Error: `Expected: "99.99", Received: 99.99`
**Causa**: Comparaci√≥n de string vs number
**Soluci√≥n**: Convertir ambos a n√∫mero antes de comparar
```typescript
if (["price", "stock"].includes(key)) {
  expected = Number(expected);
  actual = Number(actual);
}
```

#### Error: `expect(received).toBe(expected) // Object.is equality`
**Causa**: Acceso incorrecto a estructura anidada de respuesta
**Soluci√≥n**: Usar patr√≥n de acceso anidado
```typescript
const productData = (response.data as any)?.data?.data || response.data;
```

#### Error: `expect(received).toBeTruthy() // Received: null`
**Causa**: Respuestas 4xx/5xx no tratadas como errores
**Soluci√≥n**: Modificar `handleApiResponse` para detectar status de error
```typescript
export function handleApiResponse(response: any, error?: any) {
  if (error) {
    testData.lastError = error;
    testData.lastResponse = null;
  } else if (response && response.status >= 400) {
    testData.lastError = {
      status: response.status,
      message: response.data?.message || 'HTTP Error',
      response: response
    };
    testData.lastResponse = null;
  } else {
    testData.lastResponse = response;
    testData.lastError = null;
  }
}
```

### 2. **Estrategia de Debugging**
1. **Identificar el step que falla**
2. **Agregar logs estrat√©gicos temporalmente**
3. **Verificar estructura de respuesta API**
4. **Corregir acceso a datos**
5. **Limpiar logs innecesarios**

---

## üìö Aprendizajes Clave

### 1. **Estructura de Respuesta API**
- Las APIs suelen devolver estructura anidada: `response.data.data.data`
- Siempre usar patr√≥n de acceso seguro: `(response.data as any)?.data?.data || response.data`
- Validar estructura real vs esperada

### 2. **Manejo de Tipos**
- Los feature files pasan strings, pero las APIs devuelven n√∫meros
- Convertir tipos antes de comparar: `Number(value)`
- Especial atenci√≥n a campos num√©ricos: `price`, `stock`, `quantity`

### 3. **Logs Estrat√©gicos**
- Solo logs de error y contexto esencial
- Formato consistente: `‚ùå Error [contexto]: [detalles]`
- Evitar logs de datos completos cuando todo funciona

### 4. **Validaci√≥n de Schema**
- Usar JSON Schema para validar respuestas
- Validar tanto estructura como tipos de datos
- Proporcionar errores descriptivos en validaciones

### 5. **Solo se pueden actualizar campos definidos en el DTO**
- Cuando se realiza un PATCH/PUT, **solo los campos definidos en el DTO correspondiente pueden ser actualizados**.
- Si intentas enviar un campo extra (no definido en el DTO), el ValidationPipe de NestJS lo rechazar√° (por ejemplo, con `forbidNonWhitelisted: true`).
- Para que un campo sea actualizable, debe estar expl√≠citamente en el DTO de update (ej: `UpdateUserDto`, `UpdateProductDto`, etc.).
- Las interfaces (`User`, `Product`, etc.) solo definen la forma del objeto en memoria, pero **no controlan la validaci√≥n de entrada**.
- Ejemplo: Si quieres permitir actualizar `isActive` en usuario, agr√©galo al `UpdateUserDto`.

---

## üîß Troubleshooting

### Problemas de Configuraci√≥n
```bash
# Error: No tests found
# Soluci√≥n: Verificar cucumber.cjs y rutas de features/steps

# Error: TypeScript compilation
# Soluci√≥n: Verificar tsconfig.json y ts-node setup

# Error: API connection
# Soluci√≥n: Verificar api.config.ts y puerto del backend
```

### Problemas de Ejecuci√≥n
```bash
# Ejecutar test espec√≠fico
npm run test:scenario "Scenario name"

# Ejecutar por tags
npm run test:single "@tag1 and @tag2"

# Debug mode
npm run test:debug
```

### Problemas de Datos
- **Fixtures**: Verificar generaci√≥n de datos v√°lidos
- **Schemas**: Verificar validaciones JSON Schema
- **Cleanup**: Verificar limpieza de datos entre tests

---

## üìö Lecciones Aprendidas

### üéØ **Lecciones Clave del Proyecto**

#### 1. **Validaci√≥n de DTOs en Backend**
- **Problema**: Los DTOs del backend no ten√≠an todas las validaciones necesarias
- **Soluci√≥n**: Agregar `@ArrayMinSize(1)` para arrays que no pueden estar vac√≠os
- **Aprendizaje**: La validaci√≥n debe ser consistente entre frontend y backend

#### 2. **Estructura de Respuesta API**
- **Problema**: Las APIs devuelven estructura anidada `response.data.data.data`
- **Soluci√≥n**: Usar patr√≥n `(response.data as any)?.data?.data || response.data`
- **Aprendizaje**: Siempre verificar la estructura real de respuesta vs esperada

#### 3. **Steps Duplicados en Cucumber**
- **Problema**: Definiciones duplicadas causan ambig√ºedad en Cucumber
- **Soluci√≥n**: Centralizar steps comunes en `hooks.ts`
- **Aprendizaje**: Un solo lugar para definiciones de steps compartidos

#### 4. **Manejo de Campos en DTOs de Actualizaci√≥n**
- **Problema**: Campos no definidos en DTOs causan errores 422
- **Soluci√≥n**: Solo enviar campos definidos en el DTO correspondiente
- **Aprendizaje**: Los DTOs controlan qu√© campos son actualizables

#### 5. **Logs Estrat√©gicos**
- **Problema**: Logs excesivos dificultando la lectura de errores
- **Soluci√≥n**: Solo logs de error con contexto esencial
- **Aprendizaje**: Logs solo cuando es necesario para debugging

#### 6. **Validaci√≥n de Schemas**
- **Problema**: Datos no coinciden con schemas esperados
- **Soluci√≥n**: Implementar validaci√≥n JSON Schema en todos los steps
- **Aprendizaje**: Validar tanto estructura como tipos de datos

#### 7. **Fixtures y Datos de Prueba**
- **Problema**: Fixtures generan datos inv√°lidos
- **Soluci√≥n**: Asegurar tipos correctos (Number vs String)
- **Aprendizaje**: Los fixtures deben generar datos v√°lidos para el backend

#### 8. **Manejo de Errores HTTP**
- **Problema**: Respuestas 4xx no se trataban como errores
- **Soluci√≥n**: Modificar `handleApiResponse` para detectar status codes de error
- **Aprendizaje**: Tratar respuestas 4xx/5xx como errores, no como respuestas exitosas

#### 9. **Comparaci√≥n de Tipos**
- **Problema**: Comparaci√≥n de string vs number en validaciones
- **Soluci√≥n**: Convertir ambos valores a Number() antes de comparar
- **Aprendizaje**: Los feature files pasan strings, las APIs devuelven n√∫meros

#### 10. **Cleanup de Datos**
- **Problema**: Datos de prueba no se limpian correctamente
- **Soluci√≥n**: Implementar cleanup robusto en hooks After
- **Aprendizaje**: Limpiar datos en orden inverso a las dependencias

### üîß **Patrones Implementados**

#### Patr√≥n de Acceso a Datos
```typescript
// ‚úÖ Patr√≥n est√°ndar
const data = (response.data as any)?.data?.data || response.data;
```

#### Patr√≥n de Manejo de Errores
```typescript
// ‚úÖ Patr√≥n est√°ndar
try {
  const response = await client.method(data);
  handleApiResponse(response);
} catch (error) {
  handleApiResponse(null, error);
}
```

#### Patr√≥n de Validaci√≥n
```typescript
// ‚úÖ Patr√≥n est√°ndar
expect(isValidResource(data)).toBe(true);
if (!isValidResource(data)) {
  const errors = getResourceValidationErrors(data);
  throw new Error(`Invalid data: ${errors.join(', ')}`);
}
```

### üìä **M√©tricas de √âxito**

#### Antes de las Correcciones
- ‚ùå Tests fallando por ambig√ºedad de steps
- ‚ùå Errores de validaci√≥n no detectados
- ‚ùå Logs excesivos dificultando debugging
- ‚ùå Datos de prueba inconsistentes

#### Despu√©s de las Correcciones
- ‚úÖ 17 scenarios (17 passed) - 100% √©xito
- ‚úÖ 115 steps (115 passed) - Sin errores
- ‚úÖ Logs limpios y estrat√©gicos
- ‚úÖ Validaciones robustas implementadas
- ‚úÖ Patrones de c√≥digo consistentes

### üéØ **Pr√≥ximos Pasos Recomendados**

1. **Aplicar patrones a otros recursos** (cart, category, etc.)
2. **Implementar m√©tricas de performance** de tests
3. **Agregar reportes personalizados** con contexto
4. **Integrar con CI/CD** pipelines
5. **Documentar nuevos aprendizajes** continuamente

---

*√öltima actualizaci√≥n: Junio 2025*
*Versi√≥n: 1.1* 